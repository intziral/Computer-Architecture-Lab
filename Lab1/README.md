## Πρώτο Εργαστήριο Αρχιτεκτονικής Προηγμένων Υπολογιστών

_ΟΜΑΔΑ 15_  
**Ιωάννης Τζιραλής** ΑΕΜ: 9198  
**Ηλίας Κορομπίλης** ΑΕΜ: 8993

### 1. Βασικές Παράμετροι Συστήματος  
Στη main του αρχείου starter_se.py δηλώνονται οι default παράμετροι του συστήματος:  
* Tύπος cpu: atomic
* Συχνότητα λειτουργίας: 4GHz
* Αριθμός πυρήνων: 1
* Είδος κύριας μνήμης: DDR3 1600 8X8
* Κανάλια: 2
* Μέγεθος κύριας μνήμης: 2GB  

Στην εντολή που εκτελούμε εμείς θέσαμε τον τύπο cpu σε minor (--cpu="minor") και οι υπόλοιπες παράμετροι πήραν τις default τιμές τους.

### 2. Τα αρχεία config.ini και config.json  
* Όντως τα αρχεία αυτά επαληθεύουν τις πληροφορίες που είχαμε για το σύστημα. Συγκεκριμένα τον τύπο CPU,
>type=MinorCPU

τη συχνότητα λειτουργίας 4GHz (εδώ μετριέται σε ns),
>clock=250

η κύρια μνήμη έχει μέγεθος 2GB και δύο κανάλια
>mem_ramges=0:2147483648  
>memories=system.mem_ctrls0.dram system.mem_ctrls1.dram

και οι caches μέγεθος γραμμής 64 bytes.
>cache_line_size=64


* Το συνολικό νούμερο των "committed" εντολών είναι 5028, όπως προκύπτει απο το αρχείο stats.txt:
>system.cpu_cluster.cpus.committedInsts           5028

Οι εντολές αυτές είναι πολύ περισσότερες από ότι θα περιμέναμε για ένα απλό πρόγραμμα σαν το "Hello World!". Αυτό συμβαίνει επειδή ο arm τρέχει πολλές εντολές για να προετοιμάσει το simulation πριν ξεκινήσει τη διαδικασία του πραγματικού προγράμματος.

* Η L2 cache προσπελάστηκε 479 φορές, όπως προκύπτει απο το αρχείο stats.txt:
>system.cpu_cluster.l2.overall_accesses::total          479

Οι προσπελάσεις της L2 cache ισούνται με τις αστοχίες στην L1. Άρα αν δεν παρεχόταν αυτή η πληροφορία από τον εξομοιωτή θα μπορούσαμε να την υπολογίσουμε με τη σχέση:
>Misses = Miss Rate x Mem accesses =
>       = (dcache.miss_rate x dcache.overall_accesses) + (icache.miss_rate x icache.overall_accesses)  


### 3. Διαφορετικά Μοντέλα in-order CPUs στον gem-5    
Στον gem-5 υπάρχουν τρία μοντέλα in-order CPUs: το MinorCPU, το TimingSimpleCPU και το AtomicSimpleCPU. Τα δύο τελευταία είναι εκδοχές του SimpleCPU μοντέλου.

#### MinorCPU  
Το MinorCPU μοντέλο είναι ένα in-order μοντέλο με σταθερό pipeline αλλά προσαρμοζόμενα data structures και συμπεριφορά εκτέλεσης. Προορίζεται για την εξομειώση επεξεργαστών με αυστηρή in-order execution συμπεριφορά και επιτρέπει την απεικόνιση της θέσης μιας εντολής μέσω του MinorTrace/minorview.py εργαλείου.

#### SimpleCPU  
Το SimpleCPU αποτελεί ένα πολύ απλό στην υλοποίηση in order μοντέλο κατασκευασμένο για χρήση σε απλά τεστ , όπου δεν είναι απαραίτητη η χρήση κάποιου πιο περίπλοκου μοντέλου.

#### AtomicSimpleCPU
Το AtomicSimpleCPU αποτελεί υλοποίηση του SimpleCPU μοντέλου που χρησιμοποιεί πρόσβαση στη μνήμη τύπου atomic(atomic memory access). Αυτό σημαίνει ότι υπολογίζει προσεγγιστικά τον χρόνο πρόσβασης στην cache από τις χρονικές προσεγγίσεις των atomic accesses οι οποίες επιστρέφουν μια προσέγγιση του χρόνου που θα χρειαστούν για το access , ενώ η επιστροφή τιμής γίνεται στο τέλος του access function. Με αυτό τον τρόπο αποφεύγεται το queuing delay και το resource contention διότι η cpu γνωρίζει προσεγγιστικά τον χρόνο πρόσβασης στην μνήμη πριν αυτή ολοκληρωθεί.

#### TimingSimpleCPU
Το TimingSimpleCPU αποτελεί υλοποίηση του SimpleCPU μοντέλου που χρησιμοποιεί πρόσβαση στη μνήμη τύπου timing(timing memory access). Αυτό σημαίνει ότι σε κάθε πρόσβαση στην cache καθυστερεί και περιμένει την απάντηση από το σύστημα μνήμης (είτε NACK εάν δεν μπορούσε να ολοκληρωθεί το αίτημα είτε την τιμή στην μνήμη που ζητήθηκε) πριν συνεχίσει την εκτέλεση εντολών ,υπάρχει δηλαδή resource contention και queuing delay , αφού ο επεξεργαστής περιμένει την ολοκλήρωση της πρόσβασης στην μνήμη για να συνεχίσει.

### Σύκριση Μοντέλων MinorCPU και TimingSimpleCPU  
Το πρόγραμμα που χρησιμοποιήσαμε παίρνει έναν μικρό πίνακα 10 στοιχείων και τον γεμίζει με τα τετράγωνα των index.  

1. **Στην αρχή μετρήσαμε τους χρόνους εκτέλεσης με συχνότητα λειτουγίας 4GHz και τύπο μνήμης DDR3-2600-x64:**
>./build/ARM/gem5.opt -d minor_default configs/example/se.py --cpu-type=MinorCPU --cpu-clock=4GHz --caches -c test_program_arm     
>./build/ARM/gem5.opt -d timing_simple_default configs/example/se.py --cpu-type=TimingSimpleCPU --cpu-clock=4GHz --caches -c test_program_arm

Ο χρόνος εκτέλεσης (sim_seconds) για κάθε μοντέλο CPU ήταν:
* MinorCPU: 0.000037s
* TimingSimpleCPU: 0.000042s  

Η MinorCPU έχει υλοποιημένο branch predictor ο οποίος έχει πολύ μεγάλο ποσοστό επιτυχίας στο προγραμμά μας που χρησιμοποιεί μόνο μία for loop. Έτσι έχει πλεονέκτημα σε σχέση με τη λογική του TimingSimpleCPU μοντέλου το οποίο μπλοκάρει την εκτέλεση περιμένοντας το αποτέλεσμα της πρόσβασης στη μνήμη. Παρόλα αυτά, λόγω της απλότητας του προγράμματος, η διαφορά στους χρόνους εκτέλεσης είναι ελάχιστη.

2. **Στη συνέχεια κάναμε αλλαγές στη συχνότητα λειτουργίας της CPU και πήραμε τα εξής αποτελέσματα:**  

|                |   1GHz   |   2GHz   |   4GHz   |
|-----------------|:--------:|:--------:|:--------:|
| MinorCPU        | 0.000057 | 0.000044 | 0.000037 |
| TimingSimpleCPU | 0.000081 | 0.000055 | 0.000042 |

Όπως περιμέναμε η αύξηση της συχνότητας λειτουργίας σημάινει και ταχύτερος χρόνος εκτέλεσης ανεξαρτήτως του μοντέλου που χρησιμοποιείται. Γενικά η TimingSimpleCPU περιορίζεται από τις αργές προσβάσεις στη μνήμη οι οποίες κάνουν bottleneck το πρόγραμμα στις μεγαλύτερες τιμές του ρολογιού. Αντίθετα η MinorCPU ευνοείται περισσότερο από τις αυξήσεις στη συχνότητα λειτουργίας αφού επιταχύνονται τα στάδια του pipeline.

3. **Τέλος, με συχνότητα λειτουργίας 2GHz, χρησιμοποιήσαμε για mem-type την DDR4-2400-x64 και την LPDDR2-S4-1066-x32 (μία χαμηλής ισχύος DRAM που χρησιμοιείται στα κινητά τηλέφωνα):**

|                 | DDR4-2400-x64 | LPDDR2-S4-1066-x32 |
|-----------------|:-------------:|:------------------:|
| MinorCPU        |    0.000042   |      0.000054      |
| TimingSimpleCPU |    0.000054   |      0.000064      |  

Οι χρόνοι εκτέλεσης με την DDR4 δεν διαφέρουν σχεδόν καθόλου από αυτούς που είχαμε με την DDR3 στο προηγούμενο ερώτημα. Αυτό συμβαίνει επειδή ο πίνακας που κατασκευάζεται στο προγραμμά μας είναι αρκετά μικρός ώστε να μη χρειάζονται πολλές απανωτές προσβάσεις στην κύρια μνήμη. Άρα παρόλο που η DDR4 είναι γρηγορότερη δεν έχουμε αισθητές αλλαγές ταχύτητας για κανένα από τα δύο μοντέλα. Ακόμα και για την LPDDR2, που είναι σημαντικά πιο αργή από τις άλλες δυο μνήμες, οι χρόνοι είναι μόνο οριακά μεγαλύτεροι.

### Κριτική Εργασίας  
Μια σημαντική αλλαγή που θα κάναμε στην εργασία θα αφορούσε το πρόγραμμα που τρέξαμε για τις συγκρίσεις των μοντέλων CPU. Ένα πρόγραμμα μεγαλύτερης πολυπλοκότητας από αυτό που χρησιμοποιήσαμε θα αναδείκνυε καλύτερα τις διαφορές ανάμεσα στη MinorCPU και τη TimingSimpleCPU και θα έκανε πιο εμφανείς τις διαφορές στους χρόνους εκτέλεσης.

### Πηγές  
* Gem-5 Documentation: [MinorCPU](http://www.gem5.org/documentation/general_docs/cpu_models/minor_cpu)
* Gem-5 Documentation: [SimpleCPU](http://www.gem5.org/documentation/general_docs/cpu_models/SimpleCPU)
* Gem-5 Tutorial: [Using the default configuration scripts](http://learning.gem5.org/book/part1/example_configs.html)
